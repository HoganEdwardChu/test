# Quick Start

## Install
### Go get
```
go get -u github.com/pinpoint-apm/pinpoint-go-agent
```

### import
``` go
import pinpoint "github.com/pinpoint-apm/pinpoint-go-agent"
```

## Requirements
Go 1.12+

## Agent Creation
Java programs can be automatically instrumented by changing the byte code using the â€‘javaagent flag, but Go programs cannot be automatically instrumented because they are compiled into native machine code. Therefore, users must add the code for measuring to the Go program they want to track.

First, you can create a pinpoint agent from the main function or the init block. After you set the application name, agentid, point collector name, and so on for ConfigOptions, you can call the NewAgent() function to create an agent.

``` go
func main() {
	opts := []pinpoint.ConfigOption{
		pinpoint.WithAppName("Your Application Name"),
		pinpoint.WithAgentId("Agent Id"),
		pinpoint.WithCollectorHost("pinpoint's collector host"),
	}
	cfg, _ := pinpoint.NewConfig(opts...)
	agent, err := pinpoint.NewAgent(cfg)
	if err != nil {
		log.Fatalf("pinpoint agent start fail: %v", err)
	}
	
	...
```

### Config Option
The functions for setting up the Pinpoint Go Agent are as follows:

* WithAppName(name string) 
  * Set the application name.
* WithAgentId(id string)
  * Set id to distinguish agent. We recommend that you enable hostname to be included.
  * If agent id is not set, automatically generated id is given.
* WithCollectorHost(host string) 
  * Set the point collector address.
* WithLogLevel(level string)
  * Sets the level of log generated by the pinpoint agent. Either debug, info, warn, or error must be set, default is info.
* WithSamplingRate(rate int)
  * Sets the sampling rate. Sample 1/rate. In other words, if the rate is 1, then it will be 100% and if it is 100, it will be 1% sampling. The default is 1.
* WithConfigFile(filePath string)
  * The aforementioned settings can be saved to the config file in YAML format. The format of the YAML setup file is as follows:
    ```
    applicationname: "MyAppName"
    collector:
      host: "collector.myhost.com"
    logLevel: "error"
    sampling:
      rate: 10
    ```
  
## Web Request Trace

As mentioned earlier, the Go application must be manually instrumented at the source code level. Pinpoint-go-agent provides plugins modules to help developers trace the many-used libraries. These modules allow you to make instruments with simple source code modifications.

### Standard HTTP Library

The pinpoint http plugin lets you trace Go's built-in 'http' packages. For example, if you want to trace the handler of the http server below,

```go
http.HandleFunc("/", indexHandler)
```
you can write code for the instruments as shown below.
```go
http.HandleFunc(phttp.WrapHandleFunc(agent, "index", "/", index))
```

The complete example code for tracing the http server's handler is as follows:
``` go
package main

import (
	pinpoint "github.com/pinpoint-apm/pinpoint-go-agent"
	phttp "github.com/pinpoint-apm/pinpoint-go-agent/plugin/http"
)

func index(w http.ResponseWriter, r *http.Request) {
	io.WriteString(w, "hello world")
}

func main() {
	opts := []pinpoint.ConfigOption{
		pinpoint.WithAppName("TraceWebRequest"),
		pinpoint.WithAgentId("TraceWebRequestAgent"),
		pinpoint.WithCollectorHost("localhost"),
	}
	cfg, _ := pinpoint.NewConfig(opts...)
	agent, err := pinpoint.NewAgent(cfg)
	if err != nil {
		log.Fatalf("pinpoint agent start fail: %v", err)
	}

	http.HandleFunc(phttp.WrapHandleFunc(agent, "index", "/", index))
	agent.Shutdown()
}
```

### Web Framwork
pinpoint-go-agent provides a plugin to track the Gin, Echo, Chi Web framework. Below is an example of tracking the handler of the Gin framework. Simply register the pinpoint gin plugin with the middleware of the Gin.

``` go
router.Use(pgin.Middleware(agent))
```
``` go
package main

import (
	"github.com/gin-gonic/gin"
	pinpoint "github.com/pinpoint-apm/pinpoint-go-agent"
	pgin "github.com/pinpoint-apm/pinpoint-go-agent/plugin/gin"
)

func hello(c *gin.Context) {
	c.Writer.WriteString("hello")
}

func main() {
	... //set up agent
	
	router := gin.Default()
	router.Use(pgin.Middleware(agent))

	router.GET("/hello", hello)
	router.Run(":8000")
}
```

### Outgoing Http Request 
If you are tracking outgoing HTTP requests, you must instrument the HTTP client. The WrapClient() function in the pinpoint http plugin allows you to trace http client calls.

``` go
func outgoing(w http.ResponseWriter, r *http.Request) {
	client := phttp.WrapClient(nil)

	request, _ := http.NewRequest("GET", "http://localhost:9000/hello", nil)
	request = request.WithContext(r.Context())

	resp, err := client.Do(request)
	if nil != err {
		io.WriteString(w, err.Error())
		return
	}
	defer resp.Body.Close()
	io.Copy(w, resp.Body)
}

func main() {
	... //setup agent
	
	http.HandleFunc(pinpointhttp.WrapHandleFunc(t, "outgoing", "/outgoing", outgoing))

	http.ListenAndServe(":8000", nil)
	t.Shutdown()
}
```

## MySQL Trace
pinpoint mysql plugin is a 'database/sql' driver that instruments the Go-MySQL-Driver(https://github.com/go-sql-driver/mysql). 
When invoking the sql.Open() function, instead of the Go-MySQL-Driver,
``` go
import "database/sql"
import _ "github.com/go-sql-driver/mysql"

db, err := sql.Open("mysql", "user:password@/dbname")
```
you can use the pinpont mysql plugin.
``` go
db, err := sql.Open("mysql-pinpoint", "root:p123@tcp(127.0.0.1:3306)/information_schema")
```

Below is a complete example of tracking MySQL calls.
``` go
package main

import (
	"database/sql"

	_ "github.com/pinpoint-apm/pinpoint-go-agent/plugin/mysql"
	pinpoint github.com/pinpoint-apm/pinpoint-go-agent"
)

func query(w http.ResponseWriter, r *http.Request) {
	tracer := pinpoint.FromContext(r.Context())

	db, err := sql.Open("mysql-pinpoint", "root:p123@tcp(127.0.0.1:3306)/information_schema")
	if nil != err {
		panic(err)
	}

	ctx := pinpoint.NewContext(context.Background(), tracer)
	row := db.QueryRowContext(ctx, "SELECT count(*) from tables")
	var count int
	row.Scan(&count)

	fmt.Println("number of tables in information_schema", count)
}

```

## Context Passing
In the example of Outgoing Http Request above, looking at the outgoing() function, there is a code that invokes the FromContext() function to acquire the tracer.

``` go
tracer := pinpoint.FromContext(r.Context())
```

In the Trace SQL example, the query() function calls the NewContext() function and adds the tracer to the go context.

``` go
ctx := pinpoint.NewContext(context.Background(), tracer)
row := db.QueryRowContext(ctx, "SELECT count(*) from tables")
```

The tracer is the object that implements the Tracer interface of the pinpoint-go-agent, which generates and stores instrumentation information. When calling the go function, we use the context of the go language to pass this tracer. Pinpoint-go-agent provides a function that adds a tracer to the context, and a function that imports a tracer from the context, respectively.

``` go
NewContext(ctx context.Context, tracer Tracer) context.Context 
FromContext(ctx context.Context) Tracer
```

For information on the go context package, visit https://golang.org/pkg/context/.

## Goroutine Trace

Because a pinpoint tracer is designed to track a single call stack, applications can be crashed if a tracer is shared on goroutines.
The Tracer.NewAsyncSpan() function should be called to create a new tracer that traces a goroutine, and then pass it to the goroutine.
To pass the tracer reference to the goroutine, there is a way to pass it over to the function parameter, through the channel, or in the context.Context.
The Tracer.EndSpan() function must be called at the end of the goroutine.

Example using function parameter:

``` go
func outGoingRequest(ctx context.Context) {
	client := phttp.WrapClient(nil)
	
	request, _ := http.NewRequest("GET", "https://github.com/pinpoint-apm/pinpoint-go-agent", nil)
	request = request.WithContext(ctx)

	resp, err := client.Do(request)
	if nil != err {
		log.Println(err.Error())
		return
	}
	defer resp.Body.Close()
    log.Println(resp.Body)
}

func asyncWithTracer(w http.ResponseWriter, r *http.Request) {
	tracer := pinpoint.FromContext(r.Context())
	wg := &sync.WaitGroup{}
	wg.Add(1)

	go func(asyncTracer pinpoint.Tracer) {
		defer wg.Done()

		defer asyncTracer.EndSpan()
		defer asyncTracer.NewSpanEvent("asyncWithTracer_goroutine").EndSpanEvent()

		ctx := pinpoint.NewContext(context.Background(), asyncTracer)
		outGoingRequest(ctx)
	}(tracer.NewAsyncSpan())

	wg.Wait()
}
```


Example using channel:

``` go
func asyncWithChan(w http.ResponseWriter, r *http.Request) {
	tracer := pinpoint.FromContext(r.Context())
	wg := &sync.WaitGroup{}
	wg.Add(1)

	ch := make(chan pinpoint.Tracer)

	go func() {
		defer wg.Done()

		asyncTracer := <-ch
		defer asyncTracer.EndSpan()
		defer asyncTracer.NewSpanEvent("asyncWithChan_goroutine").EndSpanEvent()

		ctx := pinpoint.NewContext(context.Background(), asyncTracer)
		outGoingRequest(ctx)
	}()

	ch <- tracer.NewAsyncSpan()

	wg.Wait()
}
```

Example using context:

``` go
func asyncWithContext(w http.ResponseWriter, r *http.Request) {
	tracer := pinpoint.FromContext(r.Context())
	wg := &sync.WaitGroup{}
	wg.Add(1)

	go func(asyncCtx context.Context) {
		defer wg.Done()

		asyncTracer := pinpoint.FromContext(asyncCtx)
		defer asyncTracer.EndSpan()
		defer asyncTracer.NewSpanEvent("asyncWithContext_goroutine").EndSpanEvent()

		ctx := pinpoint.NewContext(context.Background(), asyncTracer)
		outGoingRequest(ctx)
	}(pinpoint.NewContext(context.Background(), tracer.NewAsyncSpan()))

	wg.Wait()
}
```
